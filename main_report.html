<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kajian Banjir 100 Tahunan Landfill B3 PT. Well Harvest Wining</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="main_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="main_report_files/libs/quarto-html/quarto.js"></script>
<script src="main_report_files/libs/quarto-html/popper.min.js"></script>
<script src="main_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="main_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="main_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="main_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="main_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="main_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="main_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Kajian Banjir 100 Tahunan Landfill B3 PT. Well Harvest Wining</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="umum" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Umum</h1>
<p>Salah satu persyaratan yang harus dipenuhi dalam penentuan kelayakan lokasi landfill B3 PT. Well Harvest Wining di Kecamatan Kendawangan Kabupaten Ketapang, Provinsi Kalimantan Barat adalah kajian hidrologi tentang analisa bebas banjir. Lokasi landfill terpilih harus mempunyai resiko yang paling minimal terkena dampak akibat banjir, bahkan kalau bisa terbebas dari genangan akibat banjir.</p>
<p>Banjir merupakan peristiwa meluapnya air sungai melebihi palung sungai atau genangan air yang terjadi pada daerah yang rendah dan tidak bisa terdrainasikan <span class="citation" data-cites="sni2415:2016">(<a href="#ref-sni2415:2016" role="doc-biblioref">SNI 2415:2016 2016</a>)</span>. Kajian mengenai banjir merupakan salah satu bagian yang penting dalam melakukan berbagai analisis, baik analisa untuk infrastruktur, saluran drainase, atau jembatan.</p>
<p>Dalam kajian banjir, besarnya (magnitude) debit didefinisikan sebagai kala ulang atau periode ulang. Dimana kala ulang merupakan waktu hipotetik dimana probabilitas kejadian debit atau hujan dengan besaran tertentu akan disamai atau dilampaui sekali dalam jangka waktu tersebut <span class="citation" data-cites="permenpuprnomor12/prt/m/2014">(<a href="#ref-permenpuprnomor12/prt/m/2014" role="doc-biblioref">Permen PUPR Nomor 12/PRT/M/2014 2014</a>)</span>.</p>
<p>Untuk melakukan kajian bebas banjir ini terdiri dari dua tahapan analisa. Yang pertama adalah analisa hidrologi dimana output dari analisa ini adalah nilai debit banjir pada berbagai kala ulang. Tahapan yang kedua adalah analisa hidrolika dimana nilai debit banjir yang telah dihitung tadi dimodelkan/disimulasikan hingga memperoleh tinggi muka air banjir serta karakteristik hidrolik lainnya seperti kecepatan dan luas genangan.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="kriteria-desain-dan-aturan-terkait" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Kriteria Desain dan Aturan Terkait</h1>
<p>Sebagai panduan (<em>guidelines</em>) dalam melakukan kajian banjir ini didasarkan pada beberapa aturan dan jurnal terkait sebagai berikut:</p>
<ul>
<li><p>Undang-undang No.&nbsp;17 Tahun 2019 Tentang Sumber Daya Air</p></li>
<li><p>SNI 2415:2016 Tentang Tata Cara Perhitungan Debit Banjir Rencana</p></li>
<li><p>SNI 7746:2012 Tentang Tata Cara Perhitungan Hujan Maksimum Boleh Jadi Dengan Metode Hersfield</p></li>
<li><p>SNI 1724:2015 Tentang Analisis Hidrologi, Hidraulik, dan Kriteria Desain Bangunan Sungai</p></li>
<li><p>Natakusumah, D. K., Hatmoko, W., &amp; Harlan, D. (2011). Prosedur Umum Perhitungan Hidrograf Satuan Sintetis dengan Cara ITB dan Beberapa Contoh Penerapannya. <em>JurnalTeknik Sipil</em>, <em>18</em>(3), 251. https://doi.org/10.5614/jts.2011.18.3.6</p></li>
</ul>
</section>
<section id="ketersediaan-data" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Ketersediaan Data</h1>
<p>Untuk melakukan kajian bebas banjir ini diperlukan data-data primer maupun sekunder yang dikumpulkan untuk kemudian diolah dan dianalisis sehingga menghasilkan informasi yang memadai sebagai dasar dari laporan hidrologi. Data primer didapatkan dari pengambilan data langsung di lapangan saat tahap pekerjaan lapangan berlangsung, sedangkan data sekunder didapatkan dari sumber lain yang telah ada sebelumnya. Rangkuman data yang digunakan pada penelitian ini baik primer maupun sekunder ditampilkan dalam <a href="#tbl-data" class="quarto-xref">Tabel&nbsp;1</a> berikut:</p>
<div id="tbl-data" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;1: Rangkuman Data Yang Digunakan Pada Kajian Ini
</figcaption>
<div aria-describedby="tbl-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 44%">
<col style="width: 20%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">No</th>
<th>Data</th>
<th>Jenis Data</th>
<th>Sumber Data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td>Data topografi</td>
<td>Data Primer</td>
<td>Pengukuran Topografi</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td>Data Batas Landfill</td>
<td>Data Primer</td>
<td>PT. Well Harvest Wining</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td>Digital Elevation Model (DEM)</td>
<td>Data Sekunder</td>
<td>DEMNAS</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td>Data Hujan Stasiun Rahadi Oesman</td>
<td>Data Sekunder</td>
<td>BMKG</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td>Data Tutupan Lahan</td>
<td>Data Sekunder</td>
<td>KLHK</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="catchment-area-ca" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> <em>Catchment Area</em> (CA)</h1>
<p>Untuk dapat menghitung debit banjir, diperlukan 2 (dua) inputan data utama. Input yang pertama adalah karakteristik dari catchment area (CA) yang ditinjau seperti luasan, panjang sungai, dan kemiringan sungai. Kemudian input kedua yang diperlukan adalah curah hujan rencana.</p>
<p>Untuk data karakteristik CA diperoleh dari deliniasi peta rupa bumi Indonesia (RBI). Hasil deliniasi menunjukkan terdapat satu CA di sekitar tapak proyek dengan luasan 32.01 Ha. Gambar CA dapat dilihat pada <a href="#fig-ca" class="quarto-xref">Gambar&nbsp;1</a> dibawah ini.</p>
<div id="fig-ca" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ca-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/ca.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="563">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ca-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Gambar&nbsp;1: Peta Catchment Area
</figcaption>
</figure>
</div>
</section>
<section id="data-dan-analisa-curah-hujan" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Data dan Analisa Curah Hujan</h1>
<section id="kondisi-curah-hujan" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="kondisi-curah-hujan"><span class="header-section-number">5.1</span> Kondisi Curah Hujan</h2>
<p>Data hujan yang digunakan mempunyai panjang waktu pengamatan selama 20 Tahun dari tahun 2002hingga tahun 2023 yang bersumber pada , berlokasi ±3.4 Km dari lokasi pekerjaan ( <a href="#fig-stahujan" class="quarto-xref">Gambar&nbsp;2</a> ). Berikut ditampilkan lokasi dan data curah hujan maksimum harian serta jumlah curah hujan bulanan rata-rata berupa tabel dan grafik pada stasiun tersebut.</p>
<div id="fig-stahujan" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-stahujan-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/ca_sta_hujan.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-stahujan-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Gambar&nbsp;2: Lokasi Stasiun Hujan Terhadap Lokasi Proyek
</figcaption>
</figure>
</div>
</section>
<section id="analisa-frekuensi" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="analisa-frekuensi"><span class="header-section-number">5.2</span> Analisa Frekuensi</h2>
<p>Analisa curah hujan maksimum rencana di Lokasi pekerjaan dilakukan dengan metoda statistik. Sebararan teoritis yang digunakan dalam analisis frekuensi dari berbagai distribusi, yaitu sebaran teoritis distribusi Normal, Log-Normal 2 parameter, Log-Pearson tipe III, dan Gumbel. Berikut ini diuraikan formula untuk menentukan kedalaman hujan periode ulang tertentu untuk setiap distribusi frekuensi hujan.</p>
<section id="distribusi-normal" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="distribusi-normal"><span class="header-section-number">5.2.1</span> Distribusi Normal</h3>
<p>Distribusi normal adalah simetris terhadap sumbu vertikal dan berbentuk lonceng yang juga disebut distribusi Gauss. Distribusi normal mempunyai dua parameter yaitu rata-rata µ dan deviasi standar s dari populasi. Dalam praktek, nilai rata-rata <span class="math inline">\(\hat{x}\)</span> dan deviasi standar <em>s</em> diturunkan dari data sampel untuk menggantikan µ dan s. Persamaan distribusi normal adalah sebagai berikut:</p>
</section>
<section id="distribusi-log-normal" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="distribusi-log-normal"><span class="header-section-number">5.2.2</span> Distribusi Log-Normal</h3>
<p>Untuk frekuensi hujan yang mengikuti distribusi Log-normal, kedalaman hujan periode ulang T dapat ditentukan sebagai berikut:</p>
</section>
<section id="distribusi-log-pearson-iii" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="distribusi-log-pearson-iii"><span class="header-section-number">5.2.3</span> Distribusi Log Pearson III</h3>
<p>Jika distribusi frekuensi hujan mengikuti distribusi Log-Pearson Tipe III, maka kedalaman hujan periode ulang T dapat ditentukan sebagai berikut:</p>
</section>
<section id="distribusi-gumbel" class="level3" data-number="5.2.4">
<h3 data-number="5.2.4" class="anchored" data-anchor-id="distribusi-gumbel"><span class="header-section-number">5.2.4</span> Distribusi Gumbel</h3>
<p>Jika distribusi frekuensi hujan mengikuti distribusi Gumbel, maka kedalaman hujan periode ulang T dapat ditentukan sebagai berikut:</p>
</section>
<section id="ringkasan-analisa-desain-curah-hujan" class="level3" data-number="5.2.5">
<h3 data-number="5.2.5" class="anchored" data-anchor-id="ringkasan-analisa-desain-curah-hujan"><span class="header-section-number">5.2.5</span> Ringkasan Analisa Desain Curah Hujan</h3>
<p>Rekapitulasi Hasil perhitungan distribusi curah hujan rencana untuk perioda ulang 2, 5, 10, 25, 50, 100, 200 dan 1000&nbsp; tahun dengan berbagai metode dapat dilihat pada Tabel dan Gambar Berikut.</p>
</section>
<section id="penentuan-distribusi-hujan" class="level3" data-number="5.2.6">
<h3 data-number="5.2.6" class="anchored" data-anchor-id="penentuan-distribusi-hujan"><span class="header-section-number">5.2.6</span> Penentuan Distribusi Hujan</h3>
<p>Selanjutnya setelah dilakukan analisa frekuensi dilakukan uji kesesuaian distribusi yang dimaksudkan untuk mengetahui kebenaran analisa curah hujan baik terhadap simpangan data vertikal ataupun simpangan data horisontal.</p>
<p>Uji kesesuaian distribusi frekuensi digunakan untuk menguji apakah pemilihan distribusi yang digunakan dalam perhitungan curah hujan rencana diterima atau ditolak, maka perlu dilakukan uji kesesuaian distribusi baik secara statistik maupun simpangan terkecil. Untuk uji simpangan digunakan metode Chi Square dan metode Smirnov Kolmogorof.</p>
</section>
</section>
<section id="koefisien-pengaliran" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="koefisien-pengaliran"><span class="header-section-number">5.3</span> Koefisien Pengaliran</h2>
<p>Hasil dari curah hujan rencana masih merupakan hujan total, sedangkan untuk menghitung debit banjir diperlukan nilai hujan efektif, artinya sudah dikurangi dengan infiltrasi lahan yang ada. Berbagai macam cara untuk menghitung hujan efektif, pada pekerjaan ini metode yang digunakan adalah metode Koefisien C atau koefisien limpasan. Karena pada lokasi yang ditinjau sebagian besar merpakan area tegalan/ladang, maka diasumsikan masuk dalam kategori daerah lahan tidak terpelihara (lihat <u><strong>==Tabel 19==</strong></u>). Dengan demikian nilai C yang diambil adalah <u><strong>==0.3==</strong></u>.</p>
</section>
<section id="hujan-efektif" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="hujan-efektif"><span class="header-section-number">5.4</span> Hujan Efektif</h2>
</section>
</section>
<section id="analisa-debit-banjir" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Analisa Debit Banjir</h1>
<section id="bagan-alir-perhitungan-debit-banjir" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="bagan-alir-perhitungan-debit-banjir"><span class="header-section-number">6.1</span> Bagan Alir Perhitungan Debit Banjir</h2>
<p>Berdasarkan SNI 2415-2016 tentang "Tata Cara Perhitungan Debit Banjir Rencana", bagan alir perhitungan banjir dapat dilihat pada <a href="#fig-bagan_alir" class="quarto-xref">Gambar&nbsp;3</a> yang memperlihatkan prosedur umum yang diperlukan untuk menghitung debit banjir berdasarkan ketersediaan data di lapangan.</p>
<div id="fig-bagan_alir" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bagan_alir-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/bagan_alir_banjir.png" class="img-fluid quarto-figure quarto-figure-center figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bagan_alir-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Gambar&nbsp;3: Bagan Alir Perhitungan Debit Rencana (Diolah dari SNI 2415:2016 Hal 6)
</figcaption>
</figure>
</div>
<p>Karena ketersediaan data dengan rentang panjang yang berada di lokasi hanyalah data hujan maksimum harian selama 20 Tahun serta luasan CA yang kurang dari 50 Km<sup>2</sup>, maka prosedur yang dilakukan berdasarkan bagan alir diatas adalah: pengumpulan data hujan harian maksimum tiap tahun pencatatan, analisa frekuensi, intensitas hujan, analisa rasional, dan terakhir memperoleh debit banjir rencana.</p>
</section>
<section id="debit-banjir-di-lokasi-proyek" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="debit-banjir-di-lokasi-proyek"><span class="header-section-number">6.2</span> Debit Banjir di Lokasi Proyek</h2>
</section>
<section id="debit-banjir-di-sungai-tengar" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="debit-banjir-di-sungai-tengar"><span class="header-section-number">6.3</span> Debit Banjir di Sungai Tengar</h2>
</section>
</section>
<section id="analisa-hidrolika" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Analisa Hidrolika</h1>
</section>
<section id="daftar-pustaka" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Daftar Pustaka</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-permenpuprnomor12/prt/m/2014" class="csl-entry" role="listitem">
Permen PUPR Nomor 12/PRT/M/2014. 2014. <span>“Permen PUPR Nomor 12/PRT/m/2014 Tentang Penyelenggaran Sistem Drainase Perkotaan.”</span>
</div>
<div id="ref-sni2415:2016" class="csl-entry" role="listitem">
SNI 2415:2016. 2016. <span>“SNI 2415:2016 Tata Cara Perhitungan Debit Banjir Rencana.”</span>
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>